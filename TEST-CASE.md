# ファイル管理システム テストケース

本文書は、ファイル管理システムの機能、特にイレギュラーケースやエッジケースに焦点を当てたテストケースを定義します。

## 1. バージョン管理機能の動的変更

### 概要
フォルダのバージョン管理設定を有効化または無効化した際の、既存ファイルおよび新規ファイルへの影響を検証します。

| No. | テストケース概要 | 前提条件 | 操作手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| 1.1 | **既存ファイルがあるフォルダでバージョン管理を有効化** | ・フォルダAが存在する。<br>・フォルダA内にファイルX (v1) が存在する。<br>・フォルダAのバージョン管理は**無効**。 | 1. フォルダAのバージョン管理を**有効**にする。<br>2. ファイルXを新しい内容で更新する(v2)。<br>3. ファイルXのバージョン履歴を確認する。 | ・ファイルX (v1) はバージョン履歴には記録されない。<br>・更新後のファイルX (v2) が現在のバージョンとなる。<br>・バージョン履歴には、v1の更新操作（上書き）を記録したv2のみが存在する。バージョン番号は1から始まる。 |
| 1.2 | **バージョン管理下のフォルダで設定を無効化** | ・フォルダBが存在し、バージョン管理が**有効**。<br>・フォルダB内にファイルYがあり、v1, v2の履歴を持つ。 | 1. フォルダBのバージョン管理を**無効**にする。<br>2. ファイルYを新しい内容で更新する(v3)。<br>3. ファイルYのバージョン履歴を確認する。<br>4. 再度、フォルダBのバージョン管理を**有効**にし、ファイルYを更新する(v4)。 | ・更新(v3)は単純な上書きとなり、新しいバージョンは作成されない。<br>・ファイルYのコンテンツはv3のものになる。<br>・バージョン履歴のAPIをコールしても、v1, v2のみが返されるべき（あるいはv3の上書き操作が履歴に残らないことを確認）。<br>・再度有効化して更新(v4)すると、v3の内容を元にした新しいバージョン(v3 or v4)が作成される。 |
| 1.3 | **バージョン管理無効化後のファイル履歴の保持** | No. 1.2の操作後。 | 1. フォルダBのバージョン管理が無効の状態で、ファイルYのバージョン履歴取得APIを呼び出す。 | ・APIはエラーを返さず、既存の履歴(v1, v2)を正しく返す。 |

## 2. ファイル/フォルダの移動

### 概要
バージョン管理設定が異なるフォルダ間でファイルやフォルダを移動させた際の挙動を検証します。

| No. | テストケース概要 | 前提条件 | 操作手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| 2.1 | **バージョン管理フォルダ → 非管理フォルダへのファイル移動** | ・フォルダV (バージョン管理:**有効**) が存在する。<br>・フォルダV内にファイルF (v1, v2) が存在する。<br>・フォルダN (バージョン管理:**無効**) が存在する。 | 1. ファイルFをフォルダVからフォルダNに移動する。<br>2. 移動先のフォルダNでファイルFを更新する。<br>3. 移動元のフォルダVに残骸がないことを確認する。 | ・ファイルFはフォルダNに正常に移動する。<br>・ファイルFの既存のバージョン履歴(v1, v2)は**保持される**。<br>・フォルダNでの更新は上書きとなり、新しいバージョンは作成されない。<br>・ファイルFの履歴を取得すると、v1, v2が返される。 |
| 2.2 | **非管理フォルダ → バージョン管理フォルダへのファイル移動** | ・フォルダN (バージョン管理:**無効**) が存在する。<br>・フォルダN内にファイルGが存在する。<br>・フォルダV (バージョン管理:**有効**) が存在する。 | 1. ファイルGをフォルダNからフォルダVに移動する。<br>2. 移動先のフォルダVでファイルGを更新する。 | ・ファイルGはフォルダVに正常に移動する。<br>・移動時点ではバージョン履歴は存在しない。<br>・フォルダVでの更新後、最初のバージョン履歴(v1)が作成される。 |
| 2.3 | **管理フォルダごと非管理フォルダの子階層へ移動** | ・フォルダV (バージョン管理:**有効**) が存在する。<br>・フォルダV内にファイルF (v1, v2) が存在する。<br>・フォルダN (バージョン管理:**無効**) が存在する。 | 1. フォルダVをフォルダNの子フォルダとして移動する。<br>2. 移動後の`N/V`内でファイルFを更新する。 | ・フォルダVは設定を維持したまま移動される（`versioning_enabled=true`）。<br>・移動後の更新でも、ファイルFの新しいバージョン(v3)が正常に作成される。 |

## 3. 削除・復元処理

### 概要
論理削除、物理削除、および復元操作がバージョン履歴を持つファイルに与える影響を検証します。

| No. | テストケース概要 | 前提条件 | 操作手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| 3.1 | **バージョン履歴を持つファイルの論理削除と復元** | ・フォルダV (バージョン管理:**有効**) が存在する。<br>・フォルダV内にファイルF (v1, v2) が存在する。 | 1. ファイルFを論理削除する。<br>2. ゴミ箱からファイルFを復元する。<br>3. 復元後、ファイルFのバージョン履歴を確認する。 | ・ファイルFが一覧から見えなくなる。<br>・ファイルFがゴミ箱一覧に表示される。<br>・復元後、ファイルFが元の場所に戻る。<br>・バージョン履歴(v1, v2)は完全に保持されている。 |
| 3.2 | **バージョン履歴を持つファイルの物理削除** | ・ファイルF (v1, v2) が論理削除されてから、物理削除の猶予期間が経過。 | 1. スケジュールされた物理削除バッチが実行される。 | ・S3ストレージから、ファイルFの**全てのバージョン**の実体（v1, v2のオブジェクト）が削除される。<br>・DBから、`FileEntity`レコードと、関連する全ての`FileHistory`レコードが削除される。 |
| 3.3 | **バージョン復元操作後の論理削除** | ・ファイルFがv2の状態。<br>・ファイルFのバージョンをv1に復元する。この操作でv3(v1のコピー)が作成される。 | 1. ファイルFを論理削除する。 | ・ファイルF (v3の状態) が正常に論理削除される。バージョン履歴はすべて保持されたままである。 |
| 3.4 | **論理削除されたフォルダ内のファイルの復元** | ・フォルダV（バージョン管理有効）を論理削除する。<br>・フォルダV内にはファイルF（v1, v2）が存在した。 | 1. フォルダVを復元する。 | ・フォルダVが復元される。<br>・フォルダV内のファイルFも自動的に復元される。<br>・ファイルFのバージョン履歴（v1, v2）は完全に保持されている。 |

## 4. 権限管理

### 概要
ファイル/フォルダの権限とバージョン管理機能の関連性を検証します。

| No. | テストケース概要 | 前提条件 | 操作手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| 4.1 | **読み取り権限のみを持つユーザーのバージョン履歴閲覧** | ・ユーザーAはファイルFに対して**読み取り(r)権限のみ**を持つ。<br>・ファイルFには複数のバージョン履歴が存在する。 | 1. ユーザーAとしてログインし、ファイルFのバージョン履歴を取得するAPIを呼び出す。 | ・APIは成功し、バージョン履歴の一覧を返す。 |
| 4.2 | **書き込み権限がないユーザーのバージョン復元** | ・ユーザーAはファイルFに対して**読み取り(r)権限のみ**を持つ。 | 1. ユーザーAとしてログインし、ファイルFを特定の過去バージョンに復元するAPIを呼び出す。 | ・APIは**権限エラー (403 Forbidden)** となる。復元は書き込み操作と見なされるため失敗する。 |
| 4.3 | **フォルダのバージョン管理設定変更の権限** | ・ユーザーAはフォルダVに対して**読み取り(r)権限のみ**を持つ。 | 1. ユーザーAとしてログインし、フォルダVのバージョン管理を有効/無効にするAPIを呼び出す。 | ・APIは**権限エラー (403 Forbidden)** となる。設定変更は書き込み権限を要求する。 |

## 5. ファイルロック機能

### 概要
ファイルのロック/アンロック機能、およびロックされたファイルに対する操作制限を検証します。

| No. | テストケース概要 | 前提条件 | 操作手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| 5.1 | **ファイルのロックとアンロック (正常系)** | ・ユーザーAはファイルF (フォルダV内) への**書き込み(w)権限**を持つ。<br>・フォルダVはバージョン管理が**有効**。 | 1. ユーザーAでログインし、ファイルFを**ロック**するAPI (`PUT /api/files/{id}/lock` with `{"locked": true}`) を呼び出す。<br>2. DBでファイルFのロック状態を確認する。<br>3. ユーザーAでファイルFを**アンロック**するAPI (`{"locked": false}`) を呼び出す。 | ・APIは成功(204 No Content)を返す。<br>・DBの`files`テーブルで、対象レコードの`is_locked`がtrue, `locked_by_user_id`がユーザーAのIDになる。<br>・アンロックAPIも成功し、`is_locked`がfalse, `locked_by_user_id`がNULLになる。 |
| 5.2 | **他ユーザーがロックしたファイルの更新** | ・ユーザーAがファイルFをロックしている。<br>・ユーザーBはファイルFへの**書き込み(w)権限**を持つ。 | 1. ユーザーBでログインし、ファイルFを更新 (内容変更、リネーム、移動、削除) しようとする。 | ・APIは**エラー (423 Locked)** を返す。 |
| 5.3 | **ロック所有者によるファイルの更新** | ・ユーザーAがファイルFをロックしている。 | 1. ユーザーAでログインし、ファイルFの内容を更新する。 | ・ファイル更新は**成功**する。 |
| 5.4 | **他ユーザーがロックしたファイルのアンロック** | ・ユーザーAがファイルFをロックしている。<br>・ユーザーBはファイルFへの**書き込み(w)権限**を持つ。 | 1. ユーザーBでログインし、ファイルFをアンロックしようとする。 | ・APIは**権限エラー (403 Forbidden)** を返す。 |
| 5.5 | **書き込み権限がないユーザーのロック操作** | ・ユーザーCはファイルFに対して**読み取り(r)権限のみ**を持つ。 | 1. ユーザーCでログインし、ファイルFをロックしようとする。 | ・APIは**権限エラー (403 Forbidden)** を返す。 |
| 5.6 | **非バージョン管理下のファイルのロック** | ・ファイルGは、バージョン管理が**無効**なフォルダN内に存在する。<br>・ユーザーAはファイルGへの書き込み権限を持つ。 | 1. ユーザーAでログインし、ファイルGをロックしようとする。 | ・APIは**エラー (400 Bad Request or 500 Internal Server Error)** となり、ロックできない旨のメッセージが返される。 (サーバーサイドで`IllegalStateException`がスローされる想定) |
| 5.7 | **ディレクトリのロック** | ・フォルダVはバージョン管理が有効。<br>・ユーザーAはフォルダVへの書き込み権限を持つ。 | 1. ユーザーAでログインし、フォルダV自体をロックしようとする。 | ・APIは**エラー (400 Bad Request)** となり、ディレクトリはロックできない旨のメッセージが返される。 |
